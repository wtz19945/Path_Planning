function [elite] = run_ga_multi_obstacle(weight, line_info, obs_list, params)
%RUN_GA_MULTI_OBSTACLE Summary of this function goes here
%   Detailed explanation goes here

A_init = line_info(1); 
B_init = line_info(2);
C = line_info(3);
end_p_init = line_info(4:5);

N = params(1);
T = params(2);
sigma = params(3);

P = pi /2 * (rand(N,1) - .5);
newP = P;

F = zeros(N,1);

elite = 0;
last_elite = 0;

for iter = 1: 100
    iter
    % Evaulate each parametrs
    for i = 1 : N
        inter_count = 0;
        inter_length = 0;
        rot = [cos(P(i)) -sin(P(i)); sin(P(i)) cos(P(i))];
        new_vec = rot * [A_init;B_init];
        
        end_p = rot * end_p_init;
        % Find number of intersections
        for j = 1: length(obs_list)
            [intersect,inter_point] = find_intersect([new_vec(1),new_vec(2),0], obs_list{j});
            % Check the intersection length
            if intersect
                inter_p1 = inter_point(1:2);
                inter_p2 = inter_point(3:4);
                if max(abs(inter_p1(1)), abs(inter_p2(1))) <= end_p(1)
                    inter_count = inter_count + 1;
                    inter_length = inter_length + norm(inter_p1 - inter_p2);
                elseif min(inter_p1(1), inter_p2(1)) >= end_p(1)
            end
        end

        F(i) = weight * [inter_count;norm(P(i))];
    end

    % Rank the population
    [F, indices] = sort(F);
    P = P(indices);
    % Generate new population
    elite = P(1);
    newP(1) = elite;
    
    for i = 2 : N
        index = randi(T);
        newP(i) = min(max(P(index) + sigma * normrnd(0,1),pi/6), -pi/6);
    end

    P = newP;
    % early stop
    if norm(elite - last_elite) < 1e-6
        break;
    end
    last_elite = elite;
end

end

